"""Admin service for logging privileged actions.

This module provides a small repository layer backed by SQLite which
persists administrator actions to an ``admin_actions`` table.  The service
itself offers a ``log_action`` helper used by various admin routes.

The previous version of this service used a standâ€‘in object for the database
layer.  The implementation here replaces that placeholder with a concrete
repository that ensures the table exists and inserts rows as actions are
logged.
"""

from __future__ import annotations

from datetime import datetime
import json
from typing import Any, Dict, Optional

from backend.models.admin_action import AdminAction
from backend.utils.db import get_conn
from backend.utils import name_generator


class AdminActionRepository:
    """Persistence layer for :class:`AdminAction` records.

    Parameters
    ----------
    db_path:
        Optional path to the SQLite database.  If omitted, the default
        application database is used.
    """

    def __init__(self, db_path: Optional[str] = None) -> None:
        self.db_path = db_path
        self._ensure_table()

    # -- internal helpers -------------------------------------------------
    def _ensure_table(self) -> None:
        """Create the ``admin_actions`` table if it does not already exist."""
        with get_conn(self.db_path) as conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS admin_actions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    admin_id INTEGER NOT NULL,
                    action_type TEXT NOT NULL,
                    payload TEXT,
                    timestamp TEXT NOT NULL
                );
                """
            )

    # -- public API -------------------------------------------------------
    def insert_admin_action(self, action: AdminAction) -> AdminAction:
        """Insert an admin action into the database.

        The ``payload`` field is stored as JSON.  The ``id`` of ``action`` is
        updated with the primary key generated by SQLite and the same instance
        is returned for convenience.
        """

        with get_conn(self.db_path) as conn:
            cur = conn.cursor()
            cur.execute(
                """
                INSERT INTO admin_actions (admin_id, action_type, payload, timestamp)
                VALUES (?, ?, ?, ?)
                """,
                (
                    action.admin_id,
                    action.action_type,
                    json.dumps(action.payload),
                    action.timestamp,
                ),
            )
            action.id = cur.lastrowid
        return action


class AdminService:
    """Business logic wrapper around :class:`AdminActionRepository`."""

    def __init__(self, repo: AdminActionRepository) -> None:
        self.repo = repo

    # -- logging ----------------------------------------------------------
    def log_action(self, admin_id: int, action_type: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Persist an administrative action.

        Parameters
        ----------
        admin_id:
            ID of the administrator performing the action.
        action_type:
            A short string describing the action.
        payload:
            Additional metadata associated with the action.

        Returns
        -------
        dict
            A dictionary representation of the stored action including its
            database-assigned ``id``.
        """

        action = AdminAction(
            id=None,
            admin_id=admin_id,
            action_type=action_type,
            payload=payload,
            timestamp=datetime.utcnow().isoformat(),
        )
        self.repo.insert_admin_action(action)
        return action.to_dict()

    # -- placeholders -----------------------------------------------------
    # The following methods are retained for backwards compatibility with
    # earlier exercises.  They delegate to similarly named repository
    # methods when present.  The repository used in the tests only implements
    # ``insert_admin_action`` so these calls are effectively no-ops.

    def reset_world(self) -> Dict[str, str]:  # pragma: no cover - legacy stub
        if hasattr(self.repo, "clear_all_data"):
            self.repo.clear_all_data()  # type: ignore[attr-defined]
        return {"status": "World reset complete."}

    def add_location(self, location_data: Dict[str, Any]) -> Dict[str, str]:  # pragma: no cover - legacy stub
        if hasattr(self.repo, "insert_location"):
            self.repo.insert_location(location_data)  # type: ignore[attr-defined]
        return {"status": "Location added."}

    def update_balancing(self, setting_name: str, value: Any) -> Dict[str, str]:  # pragma: no cover - legacy stub
        if hasattr(self.repo, "update_game_balance"):
            self.repo.update_game_balance(setting_name, value)  # type: ignore[attr-defined]
        return {"status": f"{setting_name} updated to {value}."}

    def add_name_to_pool(self, gender: str | None, name: str) -> Dict[str, str]:
        """Append a name to the appropriate generator pool and refresh lists."""

        name_generator.append_name(gender, name)
        return {"status": "name added"}

